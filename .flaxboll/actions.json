{"1756482342249":{"actionType":"saveAll","createdAt":"1756482342249","actionID":"1756482342249","userID":"#TEMP","path":"system.capsules.938bc73d-5ea1-4c7e-b04b-ffe1b51f1c9c.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"// ---------- import Local Tools\nimport { getCtData, testVarType } from '../../project';\nimport {\n  getFirestore,\n  doc,\n  setDoc,\n  collection,\n  Timestamp,\n} from 'firebase/firestore';\n\nexport const css1 =\n  'color: green; background-color: black; font-size: 11px; padding: 2px 6px; border-radius: 3px';\nexport const css2 =\n  'color: yellow; background-color: green; font-size: 10px; padding: 2px 6px; border-radius: 3px';\n\ntype Tprops = {\n  args: any;\n  pass: {\n    arrRefStrings: string[];\n    arrPathData: string[];\n    arrFuncs: any[];\n  };\n};\n\nexport const setDocTool = async (props: Tprops) => {\n  // ---------- set Props\n  const { args, pass } = props;\n  const { arrRefStrings, arrPathData, arrFuncs } = pass;\n\n  // -----------------------------\n  // ---------- set Firestore Call\n  // -----------------------------\n  const newArrStringRefs = arrRefStrings.map(i => {\n    const varValue = testVarType(i, args);\n    return varValue;\n  });\n\n  console.log('3', { newArrStringRefs });\n\n  const fbInit = getCtData('all.temp.fireInit');\n  const fireInit = getFirestore(fbInit);\n  console.log({ fireInit });\n  const refColl = collection(fireInit, ...newArrStringRefs);\n  const refDoc = doc(refColl);\n\n  // ------ check Data\n  if (!Array.isArray(arrRefStrings))\n    return console.log('newArrRef needs to be a string array', newArrRef);\n\n  // ------ read Data\n  let dataToSet = {};\n  const newPath = arrPathData.map(i => {\n    const varValue = testVarType(i, args);\n    return varValue;\n  });\n  dataToSet = getCtData(newPath.join('.'));\n\n  // ------ add new id\n  dataToSet.docId = refDoc.id;\n  dataToSet.createdAt = Timestamp.now();\n\n  await setDoc(refDoc, dataToSet).catch(err =>\n    console.log('Erro do setDoc', { err }),\n  );\n\n  // ---------- set Get Value Functions\n  for (const currFunc of arrFuncs) await currFunc(dataToSet, args);\n\n  console.log('%csetDoc ok', css1);\n  console.log('%cReferencia do Documento', css2, {\n    newArrStringRefs,\n    dataToSet,\n  });\n\n  return dataToSet;\n};","newValue":"// ---- setDoc.ts\n// ---------- import Local Tools\nimport { getCtData, testVarType } from '../../project';\nimport {\n  getFirestore,\n  doc,\n  setDoc,\n  collection,\n  Timestamp,\n} from 'firebase/firestore';\n\nexport const css1 =\n  'color: green; background-color: black; font-size: 11px; padding: 2px 6px; border-radius: 3px';\nexport const css2 =\n  'color: yellow; background-color: green; font-size: 10px; padding: 2px 6px; border-radius: 3px';\n\ntype Tprops = {\n  args: any;\n  pass: {\n    arrRefStrings: string[];\n    arrPathData: string[];\n    arrFuncs: any[];\n  };\n};\n\nexport const setDocTool = async (props: Tprops) => {\n  // ---------- set Props\n  const { args, pass } = props;\n  const { arrRefStrings, arrPathData, arrFuncs } = pass;\n\n  // -----------------------------\n  // ---------- set Firestore Call\n  // -----------------------------\n  // dentro do setDocTool, logo após montar newArrStringRefs:\n  const newArrStringRefs = arrRefStrings.map(i => testVarType(i, args));\n  console.log('3', { newArrStringRefs });\n\n  // validação dos segmentos\n  const hasBadRef =\n    !Array.isArray(newArrStringRefs) ||\n    newArrStringRefs.length === 0 ||\n    newArrStringRefs.some(s => typeof s !== 'string' || !s.length);\n\n  if (hasBadRef) {\n    console.log('updateDocTool: referência inválida para Firestore doc()', {\n      arrRefStrings,\n      newArrStringRefs,\n    });\n    return; // evita chamar doc() com undefined\n  }\n\n  console.log('3', { newArrStringRefs });\n\n  const fbInit = getCtData('all.temp.fireInit');\n  const fireInit = getFirestore(fbInit);\n  console.log({ fireInit });\n  const refColl = collection(fireInit, ...newArrStringRefs);\n  const refDoc = doc(refColl);\n\n  // ------ check Data\n  if (!Array.isArray(arrRefStrings))\n    return console.log('newArrRef needs to be a string array', newArrRef);\n\n  // ------ read Data\n  let dataToSet: any = {};\n\n  // Resolve cada item de arrPathData com testVarType.\n  // - Se o item for '$var_...' e apontar para um path completo, já vem o VALOR (objeto/array/prim).\n  // - Se for literal de caminho, permanece string (ex.: 'sc.a0.forms.iptsChanges').\n  const resolvedParts = (arrPathData || []).map(i => testVarType(i, args));\n\n  const onlyOneStringPath =\n    resolvedParts.length === 1 && typeof resolvedParts[0] === 'string';\n\n  const allStrings =\n    resolvedParts.length > 0 && resolvedParts.every(i => typeof i === 'string');\n\n  // (1) Array com caminho direto: ['sc.a0.forms.iptsChanges']\n  if (onlyOneStringPath) {\n    const obj = getCtData(resolvedParts[0] as string);\n    if (obj && typeof obj === 'object') dataToSet = Object.assign({}, obj);\n    else dataToSet = {}; // garante objeto\n  }\n  // (2) Caminho dinâmico por segmentos (tudo string): ['sc.', '$var_all.currScreen', 'a0.forms.iptsChanges']\n  else if (allStrings) {\n    const fullPath = (resolvedParts as string[]).join('');\n    const obj = getCtData(fullPath);\n    if (obj && typeof obj === 'object') dataToSet = Object.assign({}, obj);\n    else dataToSet = {}; // garante objeto\n  }\n  // (3) Achatar múltiplas fontes num único objeto\n  else {\n    // Cada parte pode ser:\n    // - objeto já resolvido (via $var_...)\n    // - string com caminho (vamos ler com getCtData)\n    for (const part of resolvedParts) {\n      if (!part) continue;\n\n      if (typeof part === 'string') {\n        const val = getCtData(part);\n        if (val && typeof val === 'object') Object.assign(dataToSet, val);\n      } else if (typeof part === 'object') {\n        Object.assign(dataToSet, part);\n      }\n      // se for primitivo, ignora para manter dataToSet como objeto\n    }\n  }\n\n  console.log({ arrPathData, resolvedParts, dataToSet });\n\n  // ------ add new id\n  dataToSet.docId = refDoc.id;\n  dataToSet.createdAt = Timestamp.now();\n\n  await setDoc(refDoc, dataToSet).catch(err =>\n    console.log('Erro do setDoc', { err }),\n  );\n\n  // ---------- set Get Value Functions\n  for (const currFunc of arrFuncs) await currFunc(dataToSet, args);\n\n  console.log('%csetDoc ok', css1);\n  console.log('%cReferencia do Documento', css2, {\n    newArrStringRefs,\n    dataToSet,\n  });\n\n  return dataToSet;\n};\n"}}