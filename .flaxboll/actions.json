{"1756478047209":{"actionType":"saveAll","createdAt":"1756478047209","actionID":"1756478047209","userID":"#TEMP","path":"system.capsules.601f77d6-dc04-48f5-aa75-03dbda348961.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"import { getFirestore, doc, updateDoc, serverTimestamp } from 'firebase/firestore';\n// ...\n\nexport const updateDocTool = async (props: Tprops) => {\n  const { args, pass } = props;\n  const { arrRefStrings, arrPathData, arrFuncs } = pass;\n\n  if (!Array.isArray(arrRefStrings)) {\n    console.log('arrRefStrings needs to be a string array', arrRefStrings);\n    return;\n  }\n\n  // Resolve refs\n  const newArrStringRefs = arrRefStrings.map(i => testVarType(i, args));\n  const fbInit = getCtData('all.temp.fireInit');\n  const fireInit = getFirestore(fbInit);\n  const refColl = doc(fireInit, ...newArrStringRefs);\n\n  // Monta o objeto a atualizar\n  const newPath = arrPathData.map(i => testVarType(i, args));\n  const joinedPath = newPath.join('.');\n  const raw = getCtData(joinedPath);\n\n  // Garante objeto\n  const dataToUpdate: Record<string, any> =\n    raw && typeof raw === 'object' ? { ...raw } : {};\n\n  // Selo de tempo do servidor\n  dataToUpdate.updatedAt = serverTimestamp();\n\n  try {\n    await updateDoc(refColl, dataToUpdate);\n    for (const currFunc of arrFuncs) await currFunc(dataToUpdate, args);\n\n    console.log('%cupdateDoc ok', css1);\n    console.log('%cReferencia do Documento', css2, { newArrStringRefs, joinedPath, dataToUpdate });\n    return dataToUpdate;\n  } catch (err) {\n    console.log('Erro do updateDoc', { err, newArrStringRefs, joinedPath, raw });\n  }\n};\n","newValue":"import { getFirestore, doc, updateDoc, serverTimestamp } from 'firebase/firestore';\n// ...\n\nexport const updateDocTool = async (props: Tprops) => {\n  const { args, pass } = props;\n  const { arrRefStrings, arrPathData, arrFuncs } = pass;\n\n  if (!Array.isArray(arrRefStrings)) {\n    console.log('arrRefStrings needs to be a string array', arrRefStrings);\n    return;\n  }\n\n  // Resolve refs\n  const newArrStringRefs = arrRefStrings.map(i => testVarType(i, args));\n  const fbInit = getCtData('all.temp.fireInit');\n  const fireInit = getFirestore(fbInit);\n  const refColl = doc(fireInit, ...newArrStringRefs);\n\n  // Monta o objeto a atualizar\n  const newPath = arrPathData.map(i => testVarType(i, args));\n  const joinedPath = newPath.join('.');\n  const raw = getCtData(joinedPath);\n\n  // Garante objeto\n  const dataToUpdate: Record<string, any> =\n    raw && typeof raw === 'object' ? { ...raw } : {};\n\n  // Selo de tempo do servidor\n  dataToUpdate.updatedAt = serverTimestamp();\n\n  try {\n    await updateDoc(refColl, dataToUpdate);\n    for (const currFunc of arrFuncs) await currFunc(dataToUpdate, args);\n\n    console.log('%cupdateDoc ok', css1);\n    console.log('%cReferencia do Documento', css2, { newArrStringRefs, joinedPath, dataToUpdate });\n    return dataToUpdate;\n  } catch (err) {\n    console.log('Erro do updateDoc', { err, newArrStringRefs, joinedPath, raw });\n  }\n};"}}